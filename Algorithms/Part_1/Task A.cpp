#include <iostream>
using namespace std;

void solve(){
    int n;
    int len = 0;
    int start = 1, finish = 2;
    int fisrt = 0, second = 0, third = 0;
    int max[3] = {0, 1, 2}; // 1 - len, 2 - start, 3 - end;
    cin >> n;
    for (int i = 1; i <= n; i++){
        fisrt = second;
        second = third;
        cin >> third;
        if (fisrt == second && second == third){
            if (max[0] < len){
                max[0] = len;
                max[1] = start;
                max[2] = finish;
            }
            start = i - 1;
            finish = i;
            len = 2;
        } else {
            len++;
            finish = i;
        }
    }
    if (max[0] < len){
        max[1] = start;
        max[2] = finish;
    }
    cout << max[1] << " " << max[2];
}

int main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    
    solve();
    return 0;
}

/* 
Конечно можно сначала запихать в массив наши чисела, а потом его пробегать, но тогда программа будет дольше
производить вычисления, т.к. ей 2 раза придётся пробежать n чисел.

Мы будем просто через проверку слева направо решать данную задачу.
Для того чтобы решить задачу мы должны проверять каждые 3 числа делая в последствии сдвиг.
Как только мы находим 3 одинаковых числа подряд, то в этот момент мы "сбрасываем" нашу длину до минимального.
В даннгом случае она будет у на 2 т.к логично, что мы проверяем по 3 числа отбрасывая предыдущее, а 2 < 3.
Каждый раз когда мы делаем "сброс" мы должны запомнить грядку, с которой должны начать и продолжить дивигаться.
С помощью простого прохода слева на право мы сможем узнать максимальную длину фотографии (начальную и последнюю грядку)

В конце решения задачи нужно не забыть проверить текущую длину с прошлой, которую мы запомнили и если она
лучше прошлой, то обновить параметры.

*/