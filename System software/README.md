# Системное программное обеспечение

+ [Курс - Операционные системы](./docs/СПО%20-%20Операционные%20системы.pdf) (там код и скрины заданий)
+ [Лабораторная работа 2](./LAB_2)

## Как проходить курсы на степике?
+ Открываем нужный курс.
+ Открываем задание, которое нужно выполнить.
+ Листаем до комментариев и там есть все ответы.
+ Профит, ты закрыл весь курс за час.

P.S.: У курса не антиплагиата т.к. он не является авторским от наших преподавателей.

## Рубежная работа (2022)
<details><summary>Рубеж 1</summary>

Изучите приведенный код.
Запишите результат вычисления выражения *ptrAdd:
```c
#include <stdio.h>

#define SIZE 15

int main() {
    int vec[SIZE];
    
    for (int i = 0; i < SIZE; i++) {
        vec[i] = i;
    }
    
    int* ptrAdd = vec + 0x7 + 6;
    int* ptrSub = ptrAdd - 2;
    int cmp = ptrSub < vec;
}
```

**Ответ:** 13

---

Для приведенного выше кода запишите результат вычисления выражения: *ptrSub.

**Ответ:** 11

---

Для приведенного выше кода запишите значение переменной cmp.

**Ответ:** 0

---

Реализуйте функцию, выделяющую память под вектор указанного размера и возвращающую типизированный указатель на его начало.   
Тип элементов вектора int.  
Требуется инициализировать вектор нулями.

**Ответ:** 
```c
int* calloc_foo(size_t size) {
return (int*) calloc(size, sizeof(int));
}
```

---

Объявите указатель на функцию, принимающую в качестве параметров три значения int и возвращающую значение целого типа.

**Ответ:** 
```c
int (*fptr)(int,int,int);
```

</details>
<details><summary>Рубеж 2</summary>

Расшифруйте аббревиатуру POSIX.

**Ответ:** Portable Operating System Interface

---

Безопасно ли писать и читать 64-х битную переменную из нескольких потоков на 32-х битной архитектуре?

**Ответ:** Нет, не безопасно.  
**Пояснение:** Пример из лекции про техническую гонку данных. Один поток записывает -1, а другой поток читает значения и может получить 0,-1,2^32-1. Но 2^32-1 это не то что мы ожидаем.

---

Название ассемблерной инструкции для перехода в режим ядра ОС.

**Ответ:** int  
**Пояснение:** [ссылка](https://www.tutorialspoint.com/assembly_programming/assembly_system_calls.htm)

---

Метод isInterrupted в Java сбрасывает флаг?

**Ответ:** Нет.  
**Пояснение:** Метод isInterrupted только возвращает результат флага, а interrupted еще и сбрасывает значение флага

---

Название структуры для описания POSIX потока в USER Space:
1. `posix_thread`
2. `std::thread`
3. `pthread_t`
4. `pthread`

**Ответ:** `pthread_t`

---

Какие конструкции на Java являются interrupted points?
1. `Thread.sleep(1000);`
2. `Thread.sleep(4000);`
3. `System.out.println("System software");`
4. `int a = 5;`

**Ответ:** 1, 2, 3.  
**Пояснение:** interrupted points это функции из которых может вылететь InterruptedException. Примерами таких функций являются: sleep, ввод/вывод, блокирующие операции. Операция присваивания даже не являетcя функцией/методом.

---

Пусть функция thread вызывается в двух потоках.  
Напишите сумму всех значений которые могут получиться в переменной `a` в результате выполнения программы.

```c
int32_t a = 0;

void* thread(void*) {
    a++;
}
```

**Ответ:** 3  
**Пояснение:** если потоки одновременно инкриминируют переменную, то можем получить 1. Если по очереди, то 2. Сумма равна 3.

---

Что делает функция `pthread_cleanup_pop`?
1. Достает только одну функцию обработчик и НЕ исполняет ее
2. Достает N функций обработчиков и НЕ исполняет их (N задается как аргумент функции)
3. Достает N функций обработчиков и исполняет их (N задается как агрумент функции)
4. Достает только одну функцию обработчик и исполняет е


**Ответ:** ?? формулировка не точная была ??  
**Пояснение:** Вообще зависит от параметра execute который передается в функцию pthread_cleanup_pop. Если true, то будет выполнено иначе просто удаляется из стека.

---

Какие ошибки многопоточного программирования присутствуют в алгоритме LockTwo с массивом flag без victim?
1. deadlock
2. use after free
3. проблема ABA
4. data race
5. livelock
6. Обращение к не валидной памяти
7. memory leak

**Ответ:** 1, 5.  
**Пояснение:** deadlock и livelock, livelock является частным случаем deadlock на котором происходит активное ожидание.

---

Выведите сумму уникальных значений value которые могут появиться в результате выполнения функции thread в двух разных потоках.
```c
int32_t value = 0;

void* thread(void*) {
    for (size_t i = 0; i < 5; i++) {
        value++;
    }
}
```

**Ответ:** 54  
**Пояснение:** От 2 до 10. Сумма уникальных значений 2+3+..+10=55-1=54. Как может получиться 2 предлагаю подумать самостоятельно

</details>
<details><summary>Рубеж 3</summary>

Что означает запись `#!/bin/perl` в первой строке командного файла?

**Ответ:** означает, что данный файл является Perl-скпритом.

---

Допустимо ли имя переменной `$var_1`?

**Ответ:** Да.

---

Опишите результат выполнения: `var=$_bob`.

**Ответ:** переменной var присваивается значение переменной _bob.

---

Объясните смысл выполнения команды: `typeset -r r; r=1`.

**Ответ:** Результат - ничего. Командная оболочка просто пропустит это, так как это ошибка. Значение переменной присвоилось в никуда: `r: readonly variable`.

---

Что означает запись вида? `!(tom|cat|tomcat)`

**Ответ:** любое кроме одного из указанных (tom|cat|tomcat).

---

Чему равна переменная `$?`?
```ksh
s='t??'; if[[$s= +(tom|cat|tomcat)]]
print $?; fi
```

**Ответ:** 0

---

Чему равна переменная `$?`?
```ksh
a=5; m=N
if (((a>=8)) || (((a>=6)) && [[ $m=[Yy]* ]]))
print $?; fi; print $?
```

**Ответ:** 0

---

Напишите команду, открывающую выходной поток номера 8 для файла fname.

**Ответ:** `8>fname`

---

Опишите действие команды: `set +o noglob`.

**Ответ:** включить режим интерпретации мета-символов

---

Напишите результат выполнения последовательности команд: 
```ksh
a="tom cat";
print "${a% *}"
```

**Ответ:** tom

</details>
<details><summary>Рубеж 4</summary>

Напишите регулярное выражение, которое соответствует номеру телефона в России.  
Считаем, что это ограничение на код: +7  
Номер телефона может содержать (опционально) символы '-', '(', ')' и пробелы.

**Ответ:** `^(\+7)?[\s\-]?\(?[0-9]{3}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{2}[\s\-]?[0-9]{2}$`

---

Напишите регулярное выражение, соответствующее адресу IPv4.  
Оно должно учитывать ограничение на диапазон значений от 0 до 255 для каждого байта.

**Ответ:** `^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\.|$)){4}`

---

Напишите регулярное выражение, которое соответствует URL.  
Включая схему HTTP, HTTPS, поддомены (опционально), домен, номер порта (опционально) путь к ресурсу (тоже опционально).

**Ответ:** `^(?:https?:\/\/)?(?:[\w]+\.){0,20}(?:\.?[\w]{2,})?(:[0-9]{0,5})?(\/\w+){0,100}$`

---

Напишите регулярное выражение, соответствующее дате в формате dd.mm.yyyy или dd.mm.yy, где dd - день, mm - месяц, yyyy - год или его две последние цифры.

**Ответ:** `^(3[01]|[12][0-9]|0?[1-9])\.(1[012]|0?[1-9])\.([0-9]{2}|[0-9]{4})$`

---

Напишите регулярное выражение, которое соответствует в точности словам net и web в тексте, повторяющимся друг за другом дважды.

**Ответ:** `(net[\s]*web).*?(net[\s]*web)`

</details>

## Экзамен (2022)
<details><summary>Экзамен</summary>

Что выведет данный скрипт в зависимости от входных данных?  
Выберите несколько вариантов.
```bash
value=$1
if [ $value -eq 100 ]
then
  echo "значение = 100"
elif [ $value -gt 100 ]
then
  echo "значение больше 100"
else
  case $value in
  [1-3]*) echo "значение между 1 и 39 (включительно)" ;;
  [4-5]*) echo "значение между 40 и 59 (включительно)" ;;
  9[1-8]*) echo "значение между 91 и 98 (включительно)" ;;
  99) echo "значение = $value" ;;
  *) echo "значение неизвестно" ;;
  esac
fi
```
1. Если первый аргумент скрипта - 35, будет выведено 'значение неизвестно'.
2. Если первый аргумент скрипта - 90, будет выведено 'значение неизвестно'.
3. Если первый аргумент скрипта - 91, будет выведено 'значение между 91 и 98 (включительно)'.
4. Если первый аргумент скрипта - 99, будет выведено 'значение = $value'.
5. Если первый аргумент скрипта - 100, будет выведено 'значение = 100'.

**Ответ:** 2, 3, 4, 5.

---

Какая команда позволяет подсчитать количество строк, слов или символов в файле?
1. `countw`
2. `wcount`
3. `wc`
4. `count p`

**Ответ:** 3.

---

Какая команда позволяет добавить нового пользователя в систему?
1. `useradd`
2. `adduser`
3. `linuxconf`
4. Все варианты ответа
5. Ни один из вариантов

**Ответ:** 4.

---

Какая из перечисленных команд не является фильтром?
1. `sort`
2. `wc`
3. `grep`
4. `cat`
5. ни одна из перечисленных

**Ответ:** 4.

---

Какая из команд в vi позволит удалить три слова?
1. `3$d`
2. `3 dw`
3. `3 x`
4. `3 dd`
5. Ни одна из перечисленных

**Ответ:** 2.

---

Каково отношение времени выполнения двух одинаковых независимых функций в одном потоке к времени выполнению каждой функции в своем потоке на одноядерном процессоре? (считаем накладные расходы на многопоточность нулевыми, ответ - число)

**Ответ:** Невозможно физически выполнять программу быстрее на одном ядре в двух потоках чем в одном потоке на одном ядре.

---

Позволят ли пользовательские потоки получить физическое ускорение, если они выполняются на одном потоке ядра?
1. Да
2. Нет

**Ответ:** 2.  
**Пояснение:** Единицей планирования является поток ядра операционной системы, поэтому он не сможет на двух и более ядрах процессора выполняться одновременно.

---

Какая функция используется для ожидания завершения работы потока?
1. `phread_wait`
2. `phtread_join`
3. `phtread_complete`
4. `phtread_kill`
5. `phtread_create`

**Ответ:** 2.

---
Зачем нужны рекурсивные примитивы синхронизации?
1. позволяют захватывать примитив синхронизации в одном потоке несколько раз
2. без них невозможно реализовать потокобезопасные рекурсивные функции
3. можно всегда обойтись без рекурсивных примитивов
4. рекурсивные примитивы быстрее нерекурсивных

**Ответ:** 1, 3.  
**Пояснение:** Рекурсивные мьютексы можно несколько раз захватывать в одном потоке. Но при этом без них можно всегда обойтись, если разделить код на две части (потокобезопасный, не потокобезопасный).

---

Когда полезно использовать `spin_mutex`?
1. всегда
2. при выделении памяти в куче
3. для синхронизации системных вызовов
4. для критических секций с быстрым вычислениями

**Ответ:** 4.  
**Пояснение:** Под spin_mutex тяжелые вычисления будут пагубно влиять на производительность. В итоге ядра процессора будут заняты ожиданием освобождения ресурсов вместо того, чтобы выполнять полезную работу. Системные вызовы являются тяжелыми операциями.

</details>